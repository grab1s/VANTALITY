local Env = getgenv and getgenv() or _G

-- Очистка старой версии
if Env.TPO_SCRIPT_INSTANCE and typeof(Env.TPO_SCRIPT_INSTANCE.Cleanup) == "function" then
    Env.TPO_SCRIPT_INSTANCE:Cleanup()
    task.wait(0.1)
end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Настройки по умолчанию
local offsetSettings = {
    X = 1.5, -- Право
    Y = 0,   -- Вверх (Глобально)
    Z = 0    -- Назад (Зум)
}

local isEnabled = false
local RENDER_ID = "Vantality_CameraOffset_V2"
local TpoController = {}

-- Параметры для Raycast (чтобы камера не проходила сквозь стены)
local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Exclude
raycastParams.IgnoreWater = true

local function updateOffset()
    if not Camera or not isEnabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    if not rootPart or not head then return end

    -- 1. Получаем ИСХОДНЫЙ CFrame камеры (как её посчитала игра)
    local currentCFrame = Camera.CFrame
    
    -- Проверка на 1-е лицо (дистанция от головы до камеры)
    -- Если мы слишком близко, выключаем оффсет, чтобы не видеть свои зубы
    if (head.Position - currentCFrame.Position).Magnitude < 1.5 then
        return 
    end

    -- 2. Расчет векторов для смещения
    -- RightVector берем у камеры (чтобы X смещал вправо относительно взгляда)
    local camRight = currentCFrame.RightVector
    -- UpVector берем ГЛОБАЛЬНЫЙ (0,1,0), чтобы Y всегда поднимал камеру вверх,
    -- даже если мы смотрим в пол. Это исправляет баг с инверсией управления.
    local worldUp = Vector3.new(0, 1, 0)
    -- LookVector берем у камеры для Z (зума)
    local camLook = currentCFrame.LookVector

    -- 3. Вычисляем желаемую позицию
    -- startPos - это точка, откуда мы "тянем" камеру. Обычно это текущая позиция камеры, 
    -- но для корректного рейкаста лучше считать от Головы + стандартный вынос.
    -- Но для совместимости просто модифицируем текущую позицию.
    
    local offsetVector = (camRight * offsetSettings.X) + (worldUp * offsetSettings.Y) + (camLook * (-offsetSettings.Z))
    
    -- Исходная позиция камеры (куда игру поставил дефолтный скрипт)
    local originPos = currentCFrame.Position
    -- Желаемая позиция с оффсетом
    local targetPos = originPos + offsetVector
    
    -- 4. Проверка стен (Raycast)
    -- Пускаем луч от Головы персонажа к Желаемой позиции камеры.
    -- Это предотвратит проход сквозь стены.
    raycastParams.FilterDescendantsInstances = {character} -- Игнорируем своего чара
    
    -- Луч идет от Головы до точки, где должна быть камера
    local rayOrigin = head.Position
    local rayDirection = targetPos - rayOrigin
    
    local rayResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    local finalPos = targetPos
    
    if rayResult then
        -- Если попали в стену, ставим камеру чуть ближе точки удара (на 0.5 студа), чтобы не клипалось
        local hitPos = rayResult.Position
        local directionToHead = (rayOrigin - hitPos).Unit
        finalPos = hitPos + (directionToHead * 0.5)
        
        -- Если из-за стены камера приблизилась слишком близко к голове, отменяем оффсет X/Y, 
        -- чтобы игрок мог нормально видеть в узких коридорах
        if (finalPos - rayOrigin).Magnitude < 2 then
            -- Плавный возврат к дефолту можно сделать, но пока просто вернем оригинальную позицию
            -- чтобы камера не застревала в голове
            -- finalPos = currentCFrame.Position -- Можно раскомментить для жесткого фикса
        end
    end

    -- 5. Применяем
    -- Сохраняем ориентацию (Rotation) камеры, меняем только позицию
    Camera.CFrame = CFrame.new(finalPos) * currentCFrame.Rotation
end

function TpoController:enable()
    if isEnabled then return end
    isEnabled = true
    RunService:UnbindFromRenderStep(RENDER_ID)
    -- Приоритет выше Camera, чтобы перезаписывать позицию в конце кадра
    RunService:BindToRenderStep(RENDER_ID, Enum.RenderPriority.Camera.Value + 10, updateOffset)
end

function TpoController:disable()
    if not isEnabled then return end
    isEnabled = false
    RunService:UnbindFromRenderStep(RENDER_ID)
end

function TpoController:updateOffset(axis, value)
    local numValue = tonumber(value)
    if not numValue then return end
    if offsetSettings[axis] ~= nil then
        offsetSettings[axis] = numValue
    end
end

local cleanupFunction = function()
    isEnabled = false
    RunService:UnbindFromRenderStep(RENDER_ID)
    if Env.TPO == TpoController then Env.TPO = nil end
    Env.TPO_SCRIPT_INSTANCE = nil
end

Env.TPO = TpoController
Env.TPO_SCRIPT_INSTANCE = { Cleanup = cleanupFunction }
