local Env = getgenv and getgenv() or _G

if Env.LuauAPI then
    Env.LuauAPI:UnloadAll()
    Env.LuauAPI = nil
end

local LuauAPI = {}
Env.LuauAPI = LuauAPI

local FileSystem = {
    Root = "Vantality",
    Folder = "Vantality/scripts"
}

if not isfolder(FileSystem.Root) then makefolder(FileSystem.Root) end
if not isfolder(FileSystem.Folder) then makefolder(FileSystem.Folder) end

local State = {
    LoadedScripts = {},
    ColumnIndex = 0,
    Columns = {"center", "right"}, 
    GUIColumns = {}, -- Сюда запишем реальные фреймы колонок
    Notifier = nil,
    TabRef = nil,
    ListBoxRef = nil
}

local function GetCleanName(path)
    return path:match("([^\\/]+)$")
end

local function GetFiles()
    local t = {}
    for _, p in pairs(listfiles(FileSystem.Folder)) do
        local n = GetCleanName(p)
        if n then table.insert(t, n) end
    end
    return t
end

local function CreateSandboxedEnv(scriptName)
    local UserEnv = setmetatable({}, {
        __index = function(self, key)
            if key == "Vantality" then return State.LoadedScripts[scriptName].API end
            return Env[key] or getfenv()[key]
        end,
        __newindex = function(self, key, value)
            getfenv()[key] = value
        end
    })
    return UserEnv
end

function LuauAPI:UnloadScript(name)
    local data = State.LoadedScripts[name]
    if not data then return end

    -- 1. Отключаем коннекты
    if data.Connections then
        for _, conn in pairs(data.Connections) do
            if conn and conn.Connected then conn:Disconnect() end
        end
    end

    -- 2. Удаляем GUI (Секцию) физически
    if data.SectionFrame and data.SectionFrame.Parent then
        data.SectionFrame:Destroy()
    end

    -- 3. Вызываем OnUnload у скрипта
    if data.Env and data.Env.OnUnload and type(data.Env.OnUnload) == "function" then
        pcall(data.Env.OnUnload)
    end

    State.LoadedScripts[name] = nil
    
    -- Обновляем список, чтобы убрать статус [LOADED] если бы мы его отображали
    State.ListBoxRef:Refresh()
end

function LuauAPI:UnloadAll()
    for name, _ in pairs(State.LoadedScripts) do
        self:UnloadScript(name)
    end
end

function LuauAPI:Execute(name, code)
    -- Проверка на повторный запуск
    if State.LoadedScripts[name] then
        if State.Notifier then State.Notifier:Notify({Title="Luau", Content="Script already running!", Icon="alert-circle"}) end
        return
    end

    local ScriptData = {
        Connections = {},
        SectionFrame = nil, -- Тут будет сам GUI объект
        SectionAPI = nil,   -- Тут функции добавления кнопок
        Env = nil
    }

    local API_Proxy = {}
    
    function API_Proxy.CreateSection(title)
        if ScriptData.SectionAPI then return ScriptData.SectionAPI end
        
        State.ColumnIndex = State.ColumnIndex + 1
        if State.ColumnIndex > #State.Columns then State.ColumnIndex = 1 end
        
        local colName = State.Columns[State.ColumnIndex]
        local guiContainer = State.GUIColumns[colName]
        
        -- Хак для получения GUI объекта: запоминаем кол-во детей до и после
        local oldChildren = guiContainer:GetChildren()
        
        local NewSectionAPI = State.TabRef:AddSection({
            Name = tostring(title),
            Position = colName
        })
        
        -- Ищем новый объект
        local newChildren = guiContainer:GetChildren()
        for _, child in pairs(newChildren) do
            local isNew = true
            for _, old in pairs(oldChildren) do
                if old == child then isNew = false break end
            end
            if isNew then
                ScriptData.SectionFrame = child -- Поймали фрейм!
                break
            end
        end
        
        ScriptData.SectionAPI = NewSectionAPI
        return NewSectionAPI
    end

    function API_Proxy.Bind(signal, callback)
        local conn = signal:Connect(callback)
        table.insert(ScriptData.Connections, conn)
        return conn
    end

    function API_Proxy.Notify(cfg)
        if State.Notifier then State.Notifier:Notify(cfg) end
    end

    ScriptData.API = API_Proxy
    State.LoadedScripts[name] = ScriptData

    local func, err = loadstring(code, name)
    if not func then
        warn("[Vantality Luau] Syntax Error:", err)
        if State.Notifier then State.Notifier:Notify({Title="Error", Content="Syntax Error", Icon="alert-triangle"}) end
        State.LoadedScripts[name] = nil
        return
    end

    local Sandbox = CreateSandboxedEnv(name)
    setfenv(func, Sandbox)
    ScriptData.Env = Sandbox

    local s, r = pcall(func)
    if not s then
        warn("[Vantality Luau] Runtime Error:", r)
        if State.Notifier then State.Notifier:Notify({Title="Error", Content="Runtime Error (F9)", Icon="alert-circle"}) end
        self:UnloadScript(name)
    else
        if State.Notifier then State.Notifier:Notify({Title="Luau", Content="Loaded: "..name, Icon="check"}) end
    end
end

function LuauAPI:Init(Tab, IgnoredSection, NotifierObj)
    State.TabRef = Tab
    State.Notifier = NotifierObj
    
    -- Получаем ссылки на реальные контейнеры колонок для правильного удаления
    -- Структура Fatality: Tab.Root -> MenuLiber -> Center/Right (ScrollingFrames)
    if Tab.Root then
        local MenuLiber = Tab.Root:FindFirstChildOfClass("Frame") -- Обычно это контейнер колонок
        if MenuLiber then
            State.GUIColumns["center"] = MenuLiber:FindFirstChild("Center")
            State.GUIColumns["right"] = MenuLiber:FindFirstChild("Right")
        end
    end
    
    local SelectedFile = nil

    State.ListBoxRef = Tab:AddListBox({
        Name = "SCRIPTS",
        Position = "left",
        Height = 350,
        Values = GetFiles(),
        Multi = false,
        Callback = function(val) SelectedFile = val end
    })

    local ControlSection = Tab:AddSection({
        Name = " ",
        Position = "left"
    })

    ControlSection:AddButton({
        Name = "Load Script",
        Callback = function()
            if not SelectedFile then return end
            local path = FileSystem.Folder .. "/" .. SelectedFile
            if isfile(path) then
                LuauAPI:Execute(SelectedFile, readfile(path))
            else
                if State.Notifier then State.Notifier:Notify({Title="Error", Content="File not found", Icon="x"}) end
                State.ListBoxRef:SetValues(GetFiles())
                State.ListBoxRef:Refresh()
            end
        end
    })

    ControlSection:AddButton({
        Name = "Unload Script",
        Callback = function()
            if not SelectedFile then return end
            if State.LoadedScripts[SelectedFile] then
                LuauAPI:UnloadScript(SelectedFile)
                if State.Notifier then State.Notifier:Notify({Title="Luau", Content="Unloaded: "..SelectedFile, Icon="trash"}) end
            else
                if State.Notifier then State.Notifier:Notify({Title="Luau", Content="Script is not loaded", Icon="info"}) end
            end
        end
    })

    ControlSection:AddButton({
        Name = "Refresh List",
        Callback = function()
            State.ListBoxRef:SetValues(GetFiles())
            State.ListBoxRef:Refresh()
            SelectedFile = nil
            if State.Notifier then State.Notifier:Notify({Title="Luau", Content="List Refreshed", Icon="refresh-cw"}) end
        end
    })

    ControlSection:AddButton({
        Name = "Delete File",
        Risky = true,
        Callback = function()
            if SelectedFile then
                local path = FileSystem.Folder .. "/" .. SelectedFile
                if isfile(path) then
                    delfile(path)
                    State.ListBoxRef:SetValues(GetFiles())
                    State.ListBoxRef:Refresh()
                    local cachedName = SelectedFile
                    SelectedFile = nil
                    self:UnloadScript(cachedName)
                    if State.Notifier then State.Notifier:Notify({Title="Luau", Content="Deleted: "..cachedName, Icon="trash-2"}) end
                end
            end
        end
    })
end

return LuauAPI
